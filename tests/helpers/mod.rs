use cairo_lang_defs::{db::DefsGroup, diagnostic_utils::StableLocation, ids::ModuleId};
use cairo_lang_filesystem::{
    db::{FilesGroup, init_dev_corelib},
    ids::{CrateId, FileLongId},
};
use cairo_lang_semantic::{
    SemanticDiagnostic, db::SemanticGroup, diagnostic::SemanticDiagnosticKind,
};
use cairo_lint::{
    CairoLintToolMetadata, CorelibContext, LinterAnalysisDatabase, LinterDiagnosticParams,
    LinterGroup, context::get_unique_allowed_names,
};
use scarb::find_scarb_managed_core;
use std::path::PathBuf;

mod scarb;
pub mod setup;

pub fn get_diags<'db>(
    crate_id: CrateId<'db>,
    db: &'db mut LinterAnalysisDatabase,
) -> Vec<SemanticDiagnostic<'db>> {
    if let Ok(path) = std::env::var("CORELIB_PATH") {
        init_dev_corelib(db, PathBuf::from(path));
    } else if let Some(path) = find_scarb_managed_core() {
        init_dev_corelib(db, path);
    } else {
        panic!("Missing corelib path. CORELIB_PATH env or Scarb managed corelib is required.");
    }
    let mut diagnostics = Vec::new();
    let module_file = db.module_main_file(ModuleId::CrateRoot(crate_id)).unwrap();
    if db.file_content(module_file).is_none() {
        match module_file.long(db) {
            FileLongId::OnDisk(_path) => {}
            FileLongId::Virtual(_) => panic!("Missing virtual file."),
            FileLongId::External(_) => (),
        }
    }

    let corelib_context = CorelibContext::new(db);
    let linter_params = LinterDiagnosticParams {
        only_generated_files: true,
        tool_metadata: get_cairo_lint_tool_metadata_with_all_lints_enabled(),
    };

    for module_id in &*db.crate_modules(crate_id) {
        diagnostics.extend(
            db.module_semantic_diagnostics(*module_id)
                .unwrap()
                .get_all(),
        );
        diagnostics.extend(
            db.linter_diagnostics(corelib_context.clone(), linter_params.clone(), *module_id)
                .into_iter()
                .map(|diag| {
                    SemanticDiagnostic::new(
                        StableLocation::new(diag.stable_ptr),
                        SemanticDiagnosticKind::PluginDiagnostic(diag),
                    )
                }),
        );
    }

    // We want to filter out the diagnostics that were generated by compiler generated code.
    // Tests are setup in a virtual file so we have to filter them out this way instead.
    diagnostics
        .into_iter()
        .filter(|diag| diag.stable_location.diagnostic_location(db).file_id == module_file)
        .collect::<Vec<_>>()
}

pub fn get_cairo_lint_tool_metadata_with_all_lints_enabled() -> CairoLintToolMetadata {
    let names = get_unique_allowed_names();
    names
        .into_iter()
        .map(|name| (name.to_string(), true))
        .collect()
}

#[macro_export]
macro_rules! test_lint_fixer {
  ($before:literal, @$expected_fix:literal) => {{
    let expected_value: &str = $before;
    test_lint_fixer!(expected_value, @$expected_fix, false);
  }};
  ($before:ident, @$expected_fix:literal) => {
    test_lint_fixer!($before, @$expected_fix, false)
  };
  ($before:literal, @$expected_fix:literal, $is_nested:literal) => {{
    let expected_value: &str = $before;
    test_lint_fixer!(expected_value, @$expected_fix, $is_nested)
  }};
  ($before:ident, @$expected_fix:literal, $is_nested:literal) => {{
    use ::cairo_lang_diagnostics::DiagnosticEntry;
    use ::itertools::Itertools;
    let mut code = String::from($before);
    let db = ::cairo_lint::LinterAnalysisDatabase::builder()
      .with_default_plugin_suite(::cairo_lang_semantic::inline_macros::get_default_plugin_suite())
      .with_default_plugin_suite(::cairo_lang_test_plugin::test_plugin_suite())
      .build()
      .unwrap();
    let diags = $crate::helpers::get_diags(
      $crate::helpers::setup::setup_test_crate_ex(db.get_mut(), $before),
      db.get_mut(),
    );
    let mut fixes = Vec::new();
    let corelib_context = ::cairo_lint::CorelibContext::new(&*db);
    let linter_params = ::cairo_lint::LinterDiagnosticParams {
        only_generated_files: true,
        tool_metadata: $crate::helpers::get_cairo_lint_tool_metadata_with_all_lints_enabled(),
    };
    fixes.extend(::cairo_lint::get_fixes(&*db, &corelib_context, &linter_params, diags).values().flatten().cloned());
    let suggestions = fixes.iter().flat_map(|fix| fix.suggestions.iter()).sorted_by_key(|s| std::cmp::Reverse(s.span.start));
    if !$is_nested {
      for suggestion in suggestions {
        code.replace_range(suggestion.span.to_str_range(), &suggestion.code);
      }
    } else {
      code = "Contains nested diagnostics can't fix it".to_string();
    }
    let after = ::cairo_lang_formatter::format_string(&*db, code);

    ::insta::assert_snapshot!(after, @$expected_fix);

    let after_db = ::cairo_lint::LinterAnalysisDatabase::builder()
      .with_default_plugin_suite(::cairo_lang_semantic::inline_macros::get_default_plugin_suite())
      .with_default_plugin_suite(::cairo_lang_test_plugin::test_plugin_suite())
      .build()
      .unwrap();

    let after_diags = $crate::helpers::get_diags(
      $crate::helpers::setup::setup_test_crate_ex(after_db.get_mut(), &after),
      after_db.get_mut(),
    );
    assert!(after_diags.iter().filter(|diag| diag.severity() == ::cairo_lang_diagnostics::Severity::Error).collect::<Vec<_>>().is_empty(), "Expected no diagnostics after fix, but found: {:?}", after_diags);
  }};
}

#[macro_export]
macro_rules! test_lint_diagnostics {
  ($before:literal, @$expected_diagnostics:literal) => {{
    let expected_value = ::indoc::indoc!($before);
    test_lint_diagnostics!(expected_value, @$expected_diagnostics)
  }};
  ($before:ident, @$expected_diagnostics:literal) => {{
    let db = ::cairo_lint::LinterAnalysisDatabase::builder()
      .with_default_plugin_suite(::cairo_lang_semantic::inline_macros::get_default_plugin_suite())
      .with_default_plugin_suite(::cairo_lang_test_plugin::test_plugin_suite())
      .build()
      .unwrap();
    let diags = $crate::helpers::get_diags(
      $crate::helpers::setup::setup_test_crate_ex(db.get_mut(), $before),
      db.get_mut(),
    );
    let formatted_diags = diags
      .into_iter()
      .map(|diag| ::cairo_lint::diagnostics::format_diagnostic(&diag, &*db))
      .collect::<String>()
      .trim()
      .to_string();
      ::insta::assert_snapshot!(formatted_diags, @$expected_diagnostics);
  }};
}
